; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\main.o --asm_dir=..\LISTING\ --list_dir=..\LISTING\ --depend=.\main.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\inc_h -IC:\ti\TivaWare_C_Series-2.1.0.12573\inc -IC:\ti\TivaWare_C_Series-2.1.0.12573\utils -IC:\ti\TivaWare_C_Series-2.1.0.12573\grlib -IC:\ti\TivaWare_C_Series-2.1.0.12573\IQmath -IC:\ti\TivaWare_C_Series-2.1.0.12573\nfclib -IC:\ti\TivaWare_C_Series-2.1.0.12573\driverlib -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\TI\TM4C123 -Drvmdk -DPART_TM4C123GH6PM -DTARGET_IS_TM4C123_RA3 -DTM4C123GH6PM --omf_browse=.\main.crf ..\APP\main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  LimitButtonCheck PROC
;;;33     uint8_t cnt1 = 0,cnt2 = 0,cnt3 	= 0,cnt4 = 0;
;;;34     static void LimitButtonCheck(void)
000000  b510              PUSH     {r4,lr}
;;;35     {
;;;36     if(M1_Read_S1 == 0x00)    //触碰到上限位
000002  f04f7080          MOV      r0,#0x1000000
000006  6a00              LDR      r0,[r0,#0x20]
000008  2180              MOVS     r1,#0x80
00000a  6ac2              LDR      r2,[r0,#0x2c]
00000c  f04f2040          MOV      r0,#0x40004000
000010  4790              BLX      r2
000012  f0100f80          TST      r0,#0x80
000016  d110              BNE      |L1.58|
;;;37     	{
;;;38     		cnt1 ++;
000018  4855              LDR      r0,|L1.368|
00001a  7800              LDRB     r0,[r0,#0]  ; cnt1
00001c  1c40              ADDS     r0,r0,#1
00001e  4954              LDR      r1,|L1.368|
000020  7008              STRB     r0,[r1,#0]
;;;39     		if(cnt1 > Delay_Limit)
000022  4608              MOV      r0,r1
000024  7800              LDRB     r0,[r0,#0]  ; cnt1
000026  2864              CMP      r0,#0x64
000028  dd10              BLE      |L1.76|
;;;40     			M1_state.Limit1 = 1; 
00002a  4852              LDR      r0,|L1.372|
00002c  6800              LDR      r0,[r0,#0]  ; M1_state
00002e  f0200001          BIC      r0,r0,#1
000032  1c40              ADDS     r0,r0,#1
000034  494f              LDR      r1,|L1.372|
000036  6008              STR      r0,[r1,#0]  ; M1_state
000038  e008              B        |L1.76|
                  |L1.58|
;;;41     	}		
;;;42     	else{	
;;;43     		cnt1 = 0;
00003a  2000              MOVS     r0,#0
00003c  494c              LDR      r1,|L1.368|
00003e  7008              STRB     r0,[r1,#0]
;;;44     		M1_state.Limit1 = 0;
000040  484c              LDR      r0,|L1.372|
000042  6800              LDR      r0,[r0,#0]  ; M1_state
000044  f0200001          BIC      r0,r0,#1
000048  494a              LDR      r1,|L1.372|
00004a  6008              STR      r0,[r1,#0]  ; M1_state
                  |L1.76|
;;;45     	}	
;;;46     	if(M1_Read_S2 == 0x00)    //触碰到下限位
00004c  f04f7080          MOV      r0,#0x1000000
000050  6a00              LDR      r0,[r0,#0x20]
000052  2108              MOVS     r1,#8
000054  6ac2              LDR      r2,[r0,#0x2c]
000056  4848              LDR      r0,|L1.376|
000058  4790              BLX      r2
00005a  f0100f08          TST      r0,#8
00005e  d110              BNE      |L1.130|
;;;47     	{
;;;48     		cnt2 ++;
000060  4846              LDR      r0,|L1.380|
000062  7800              LDRB     r0,[r0,#0]  ; cnt2
000064  1c40              ADDS     r0,r0,#1
000066  4945              LDR      r1,|L1.380|
000068  7008              STRB     r0,[r1,#0]
;;;49     		if(cnt2 > Delay_Limit)
00006a  4608              MOV      r0,r1
00006c  7800              LDRB     r0,[r0,#0]  ; cnt2
00006e  2864              CMP      r0,#0x64
000070  dd10              BLE      |L1.148|
;;;50     			M1_state.Limit2 = 1; 
000072  4840              LDR      r0,|L1.372|
000074  6800              LDR      r0,[r0,#0]  ; M1_state
000076  f0200002          BIC      r0,r0,#2
00007a  1c80              ADDS     r0,r0,#2
00007c  493d              LDR      r1,|L1.372|
00007e  6008              STR      r0,[r1,#0]  ; M1_state
000080  e008              B        |L1.148|
                  |L1.130|
;;;51     	}
;;;52     	else{
;;;53     		cnt2 = 0;
000082  2000              MOVS     r0,#0
000084  493d              LDR      r1,|L1.380|
000086  7008              STRB     r0,[r1,#0]
;;;54     		M1_state.Limit2 = 0; 
000088  483a              LDR      r0,|L1.372|
00008a  6800              LDR      r0,[r0,#0]  ; M1_state
00008c  f0200002          BIC      r0,r0,#2
000090  4938              LDR      r1,|L1.372|
000092  6008              STR      r0,[r1,#0]  ; M1_state
                  |L1.148|
;;;55     	}
;;;56     	
;;;57     	if(M2_Read_S1 == 0x00)    //触碰到左限位（从背面看）
000094  f04f7080          MOV      r0,#0x1000000
000098  6a00              LDR      r0,[r0,#0x20]
00009a  2104              MOVS     r1,#4
00009c  6ac2              LDR      r2,[r0,#0x2c]
00009e  4836              LDR      r0,|L1.376|
0000a0  4790              BLX      r2
0000a2  f0100f04          TST      r0,#4
0000a6  d110              BNE      |L1.202|
;;;58     	{
;;;59     		cnt3 ++;
0000a8  4835              LDR      r0,|L1.384|
0000aa  7800              LDRB     r0,[r0,#0]  ; cnt3
0000ac  1c40              ADDS     r0,r0,#1
0000ae  4934              LDR      r1,|L1.384|
0000b0  7008              STRB     r0,[r1,#0]
;;;60     		if(cnt3 > Delay_Limit)
0000b2  4608              MOV      r0,r1
0000b4  7800              LDRB     r0,[r0,#0]  ; cnt3
0000b6  2864              CMP      r0,#0x64
0000b8  dd10              BLE      |L1.220|
;;;61     			M2_state.Limit1 = 1; 
0000ba  4832              LDR      r0,|L1.388|
0000bc  6800              LDR      r0,[r0,#0]  ; M2_state
0000be  f0200001          BIC      r0,r0,#1
0000c2  1c40              ADDS     r0,r0,#1
0000c4  492f              LDR      r1,|L1.388|
0000c6  6008              STR      r0,[r1,#0]  ; M2_state
0000c8  e008              B        |L1.220|
                  |L1.202|
;;;62     	}	 
;;;63     	else{
;;;64     		cnt3 = 0;
0000ca  2000              MOVS     r0,#0
0000cc  492c              LDR      r1,|L1.384|
0000ce  7008              STRB     r0,[r1,#0]
;;;65     		M2_state.Limit1 = 0;
0000d0  482c              LDR      r0,|L1.388|
0000d2  6800              LDR      r0,[r0,#0]  ; M2_state
0000d4  f0200001          BIC      r0,r0,#1
0000d8  492a              LDR      r1,|L1.388|
0000da  6008              STR      r0,[r1,#0]  ; M2_state
                  |L1.220|
;;;66     	} 
;;;67     	if(M2_Read_S2 == 0x00)    //触碰到右限位（从背面看）
0000dc  f04f7080          MOV      r0,#0x1000000
0000e0  6a00              LDR      r0,[r0,#0x20]
0000e2  2102              MOVS     r1,#2
0000e4  6ac2              LDR      r2,[r0,#0x2c]
0000e6  4824              LDR      r0,|L1.376|
0000e8  4790              BLX      r2
0000ea  f0100f02          TST      r0,#2
0000ee  d110              BNE      |L1.274|
;;;68     	{
;;;69     		cnt4 ++;
0000f0  4825              LDR      r0,|L1.392|
0000f2  7800              LDRB     r0,[r0,#0]  ; cnt4
0000f4  1c40              ADDS     r0,r0,#1
0000f6  4924              LDR      r1,|L1.392|
0000f8  7008              STRB     r0,[r1,#0]
;;;70     		if(cnt4 > Delay_Limit)
0000fa  4608              MOV      r0,r1
0000fc  7800              LDRB     r0,[r0,#0]  ; cnt4
0000fe  2864              CMP      r0,#0x64
000100  dd10              BLE      |L1.292|
;;;71     			M2_state.Limit2 = 1; 
000102  4820              LDR      r0,|L1.388|
000104  6800              LDR      r0,[r0,#0]  ; M2_state
000106  f0200002          BIC      r0,r0,#2
00010a  1c80              ADDS     r0,r0,#2
00010c  491d              LDR      r1,|L1.388|
00010e  6008              STR      r0,[r1,#0]  ; M2_state
000110  e008              B        |L1.292|
                  |L1.274|
;;;72     	}	
;;;73     	else{
;;;74     		cnt4 = 0;
000112  2000              MOVS     r0,#0
000114  491c              LDR      r1,|L1.392|
000116  7008              STRB     r0,[r1,#0]
;;;75     		M2_state.Limit2 = 0; 
000118  481a              LDR      r0,|L1.388|
00011a  6800              LDR      r0,[r0,#0]  ; M2_state
00011c  f0200002          BIC      r0,r0,#2
000120  4918              LDR      r1,|L1.388|
000122  6008              STR      r0,[r1,#0]  ; M2_state
                  |L1.292|
;;;76     	}		
;;;77     }
000124  bd10              POP      {r4,pc}
;;;78     
                          ENDP

                  main PROC
;;;6      
;;;7      int main(void)
000126  f7fffffe          BL       SystemInit
;;;8      {
;;;9      	SystemInit();
;;;10     	while(1)
00012a  e01f              B        |L1.364|
                  |L1.300|
;;;11     	{
;;;12     		LimitButtonCheck();      //限位检测
00012c  f7fffffe          BL       LimitButtonCheck
;;;13     		Can1_DataDeal();         //处理CAN数据包
000130  f7fffffe          BL       Can1_DataDeal
;;;14     		
;;;15     		
;;;16     		if(Motor_New_Cmd1 == 1)//电机 1 新控制指令到达
000134  4815              LDR      r0,|L1.396|
000136  8800              LDRH     r0,[r0,#0]  ; Flagbits
000138  f3c02000          UBFX     r0,r0,#8,#1
00013c  b108              CBZ      r0,|L1.322|
;;;17     			STEP_Start1();//电机 1 参数初始化
00013e  f7fffffe          BL       STEP_Start1
                  |L1.322|
;;;18     		 
;;;19     		if(Motor_New_Cmd2 == 1)//电机 2 新控制指令到达
000142  4812              LDR      r0,|L1.396|
000144  8800              LDRH     r0,[r0,#0]  ; Flagbits
000146  f3c02040          UBFX     r0,r0,#9,#1
00014a  b108              CBZ      r0,|L1.336|
;;;20     			STEP_Start2();//电机 2 参数初始化
00014c  f7fffffe          BL       STEP_Start2
                  |L1.336|
;;;21     		
;;;22     		if(MotorTime_Pulse1 == 1)//新的步数执行完毕  软启停
000150  480e              LDR      r0,|L1.396|
000152  7800              LDRB     r0,[r0,#0]  ; Flagbits
000154  f0100f01          TST      r0,#1
000158  d001              BEQ      |L1.350|
;;;23     			SOFT_Start_M1();
00015a  f7fffffe          BL       SOFT_Start_M1
                  |L1.350|
;;;24     		
;;;25     		if(MotorTime_Pulse2 == 1)//新的步数执行完毕  软启停
00015e  480b              LDR      r0,|L1.396|
000160  7800              LDRB     r0,[r0,#0]  ; Flagbits
000162  f3c00040          UBFX     r0,r0,#1,#1
000166  b108              CBZ      r0,|L1.364|
;;;26     			SOFT_Start_M2();
000168  f7fffffe          BL       SOFT_Start_M2
                  |L1.364|
00016c  e7de              B        |L1.300|
;;;27     	}	
;;;28     }
;;;29     
                          ENDP

00016e  0000              DCW      0x0000
                  |L1.368|
                          DCD      cnt1
                  |L1.372|
                          DCD      M1_state
                  |L1.376|
                          DCD      0x40025000
                  |L1.380|
                          DCD      cnt2
                  |L1.384|
                          DCD      cnt3
                  |L1.388|
                          DCD      M2_state
                  |L1.392|
                          DCD      cnt4
                  |L1.396|
                          DCD      Flagbits

                          AREA ||.data||, DATA, ALIGN=0

                  cnt1
000000  00                DCB      0x00
                  cnt2
000001  00                DCB      0x00
                  cnt3
000002  00                DCB      0x00
                  cnt4
000003  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
