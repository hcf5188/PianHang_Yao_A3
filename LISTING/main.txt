; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\main.o --asm_dir=..\LISTING\ --list_dir=..\LISTING\ --depend=.\main.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I..\inc_h -IC:\ti\TivaWare_C_Series-2.1.0.12573\inc -IC:\ti\TivaWare_C_Series-2.1.0.12573\utils -IC:\ti\TivaWare_C_Series-2.1.0.12573\grlib -IC:\ti\TivaWare_C_Series-2.1.0.12573\IQmath -IC:\ti\TivaWare_C_Series-2.1.0.12573\nfclib -IC:\ti\TivaWare_C_Series-2.1.0.12573\driverlib -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\TI\TM4C123 -Drvmdk -DPART_TM4C123GH6PM -DTARGET_IS_TM4C123_RA3 -DTM4C123GH6PM --omf_browse=.\main.crf ..\APP\main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  LimitButtonCheck PROC
;;;33     uint8_t cnt1 = 0,cnt2 = 0,cnt3 	= 0,cnt4 = 0;
;;;34     static void LimitButtonCheck(void)
000000  b510              PUSH     {r4,lr}
;;;35     {
;;;36     if(M1_Read_S1 == 0x00)    //触碰到上限位
000002  f04f7080          MOV      r0,#0x1000000
000006  6a00              LDR      r0,[r0,#0x20]
000008  2108              MOVS     r1,#8
00000a  6ac2              LDR      r2,[r0,#0x2c]
00000c  f04f2040          MOV      r0,#0x40004000
000010  4790              BLX      r2
000012  f0100f08          TST      r0,#8
000016  d110              BNE      |L1.58|
;;;37     	{
;;;38     		cnt1 ++;
000018  4855              LDR      r0,|L1.368|
00001a  7800              LDRB     r0,[r0,#0]  ; cnt1
00001c  1c40              ADDS     r0,r0,#1
00001e  4954              LDR      r1,|L1.368|
000020  7008              STRB     r0,[r1,#0]
;;;39     		if(cnt1 > Delay_Limit)
000022  4608              MOV      r0,r1
000024  7800              LDRB     r0,[r0,#0]  ; cnt1
000026  2864              CMP      r0,#0x64
000028  dd10              BLE      |L1.76|
;;;40     			M1_state.Limit1 = 1; 
00002a  4852              LDR      r0,|L1.372|
00002c  6800              LDR      r0,[r0,#0]  ; M1_state
00002e  f0200001          BIC      r0,r0,#1
000032  1c40              ADDS     r0,r0,#1
000034  494f              LDR      r1,|L1.372|
000036  6008              STR      r0,[r1,#0]  ; M1_state
000038  e008              B        |L1.76|
                  |L1.58|
;;;41     	}		
;;;42     	else{	
;;;43     		cnt1 = 0;
00003a  2000              MOVS     r0,#0
00003c  494c              LDR      r1,|L1.368|
00003e  7008              STRB     r0,[r1,#0]
;;;44     		M1_state.Limit1 = 0;
000040  484c              LDR      r0,|L1.372|
000042  6800              LDR      r0,[r0,#0]  ; M1_state
000044  f0200001          BIC      r0,r0,#1
000048  494a              LDR      r1,|L1.372|
00004a  6008              STR      r0,[r1,#0]  ; M1_state
                  |L1.76|
;;;45     	}	
;;;46     	if(M1_Read_S2 == 0x00)    //触碰到下限位
00004c  f04f7080          MOV      r0,#0x1000000
000050  6a00              LDR      r0,[r0,#0x20]
000052  2110              MOVS     r1,#0x10
000054  6ac2              LDR      r2,[r0,#0x2c]
000056  f04f2040          MOV      r0,#0x40004000
00005a  4790              BLX      r2
00005c  f0100f10          TST      r0,#0x10
000060  d110              BNE      |L1.132|
;;;47     	{
;;;48     		cnt2 ++;
000062  4845              LDR      r0,|L1.376|
000064  7800              LDRB     r0,[r0,#0]  ; cnt2
000066  1c40              ADDS     r0,r0,#1
000068  4943              LDR      r1,|L1.376|
00006a  7008              STRB     r0,[r1,#0]
;;;49     		if(cnt2 > Delay_Limit)
00006c  4608              MOV      r0,r1
00006e  7800              LDRB     r0,[r0,#0]  ; cnt2
000070  2864              CMP      r0,#0x64
000072  dd10              BLE      |L1.150|
;;;50     			M1_state.Limit2 = 1; 
000074  483f              LDR      r0,|L1.372|
000076  6800              LDR      r0,[r0,#0]  ; M1_state
000078  f0200002          BIC      r0,r0,#2
00007c  1c80              ADDS     r0,r0,#2
00007e  493d              LDR      r1,|L1.372|
000080  6008              STR      r0,[r1,#0]  ; M1_state
000082  e008              B        |L1.150|
                  |L1.132|
;;;51     	}
;;;52     	else{
;;;53     		cnt2 = 0;
000084  2000              MOVS     r0,#0
000086  493c              LDR      r1,|L1.376|
000088  7008              STRB     r0,[r1,#0]
;;;54     		M1_state.Limit2 = 0; 
00008a  483a              LDR      r0,|L1.372|
00008c  6800              LDR      r0,[r0,#0]  ; M1_state
00008e  f0200002          BIC      r0,r0,#2
000092  4938              LDR      r1,|L1.372|
000094  6008              STR      r0,[r1,#0]  ; M1_state
                  |L1.150|
;;;55     	}
;;;56     	
;;;57     	if(M2_Read_S1 == 0x00)    //触碰到左限位（从背面看）
000096  f04f7080          MOV      r0,#0x1000000
00009a  6a00              LDR      r0,[r0,#0x20]
00009c  2140              MOVS     r1,#0x40
00009e  6ac2              LDR      r2,[r0,#0x2c]
0000a0  4836              LDR      r0,|L1.380|
0000a2  4790              BLX      r2
0000a4  f0100f40          TST      r0,#0x40
0000a8  d110              BNE      |L1.204|
;;;58     	{
;;;59     		cnt3 ++;
0000aa  4835              LDR      r0,|L1.384|
0000ac  7800              LDRB     r0,[r0,#0]  ; cnt3
0000ae  1c40              ADDS     r0,r0,#1
0000b0  4933              LDR      r1,|L1.384|
0000b2  7008              STRB     r0,[r1,#0]
;;;60     		if(cnt3 > Delay_Limit)
0000b4  4608              MOV      r0,r1
0000b6  7800              LDRB     r0,[r0,#0]  ; cnt3
0000b8  2864              CMP      r0,#0x64
0000ba  dd10              BLE      |L1.222|
;;;61     			M2_state.Limit1 = 1; 
0000bc  4831              LDR      r0,|L1.388|
0000be  6800              LDR      r0,[r0,#0]  ; M2_state
0000c0  f0200001          BIC      r0,r0,#1
0000c4  1c40              ADDS     r0,r0,#1
0000c6  492f              LDR      r1,|L1.388|
0000c8  6008              STR      r0,[r1,#0]  ; M2_state
0000ca  e008              B        |L1.222|
                  |L1.204|
;;;62     	}	 
;;;63     	else{
;;;64     		cnt3 = 0;
0000cc  2000              MOVS     r0,#0
0000ce  492c              LDR      r1,|L1.384|
0000d0  7008              STRB     r0,[r1,#0]
;;;65     		M2_state.Limit1 = 0;
0000d2  482c              LDR      r0,|L1.388|
0000d4  6800              LDR      r0,[r0,#0]  ; M2_state
0000d6  f0200001          BIC      r0,r0,#1
0000da  492a              LDR      r1,|L1.388|
0000dc  6008              STR      r0,[r1,#0]  ; M2_state
                  |L1.222|
;;;66     	} 
;;;67     	if(M2_Read_S2 == 0x00)    //触碰到右限位（从背面看）
0000de  f04f7080          MOV      r0,#0x1000000
0000e2  6a00              LDR      r0,[r0,#0x20]
0000e4  2180              MOVS     r1,#0x80
0000e6  6ac2              LDR      r2,[r0,#0x2c]
0000e8  4824              LDR      r0,|L1.380|
0000ea  4790              BLX      r2
0000ec  f0100f80          TST      r0,#0x80
0000f0  d110              BNE      |L1.276|
;;;68     	{
;;;69     		cnt4 ++;
0000f2  4825              LDR      r0,|L1.392|
0000f4  7800              LDRB     r0,[r0,#0]  ; cnt4
0000f6  1c40              ADDS     r0,r0,#1
0000f8  4923              LDR      r1,|L1.392|
0000fa  7008              STRB     r0,[r1,#0]
;;;70     		if(cnt4 > Delay_Limit)
0000fc  4608              MOV      r0,r1
0000fe  7800              LDRB     r0,[r0,#0]  ; cnt4
000100  2864              CMP      r0,#0x64
000102  dd10              BLE      |L1.294|
;;;71     			M2_state.Limit2 = 1; 
000104  481f              LDR      r0,|L1.388|
000106  6800              LDR      r0,[r0,#0]  ; M2_state
000108  f0200002          BIC      r0,r0,#2
00010c  1c80              ADDS     r0,r0,#2
00010e  491d              LDR      r1,|L1.388|
000110  6008              STR      r0,[r1,#0]  ; M2_state
000112  e008              B        |L1.294|
                  |L1.276|
;;;72     	}	
;;;73     	else{
;;;74     		cnt4 = 0;
000114  2000              MOVS     r0,#0
000116  491c              LDR      r1,|L1.392|
000118  7008              STRB     r0,[r1,#0]
;;;75     		M2_state.Limit2 = 0; 
00011a  481a              LDR      r0,|L1.388|
00011c  6800              LDR      r0,[r0,#0]  ; M2_state
00011e  f0200002          BIC      r0,r0,#2
000122  4918              LDR      r1,|L1.388|
000124  6008              STR      r0,[r1,#0]  ; M2_state
                  |L1.294|
;;;76     	}		
;;;77     }
000126  bd10              POP      {r4,pc}
;;;78     
                          ENDP

                  main PROC
;;;6      
;;;7      int main(void)
000128  f7fffffe          BL       SystemInit
;;;8      {
;;;9      	SystemInit();
;;;10     	while(1)
00012c  e01f              B        |L1.366|
                  |L1.302|
;;;11     	{
;;;12     		LimitButtonCheck();      //限位检测
00012e  f7fffffe          BL       LimitButtonCheck
;;;13     		Can1_DataDeal();         //处理CAN数据包
000132  f7fffffe          BL       Can1_DataDeal
;;;14     		
;;;15     		
;;;16     		if(Motor_New_Cmd1 == 1)//电机 1 新控制指令到达
000136  4815              LDR      r0,|L1.396|
000138  8800              LDRH     r0,[r0,#0]  ; Flagbits
00013a  f3c02000          UBFX     r0,r0,#8,#1
00013e  b108              CBZ      r0,|L1.324|
;;;17     			STEP_Start1();//电机 1 参数初始化
000140  f7fffffe          BL       STEP_Start1
                  |L1.324|
;;;18     		 
;;;19     		if(Motor_New_Cmd2 == 1)//电机 2 新控制指令到达
000144  4811              LDR      r0,|L1.396|
000146  8800              LDRH     r0,[r0,#0]  ; Flagbits
000148  f3c02040          UBFX     r0,r0,#9,#1
00014c  b108              CBZ      r0,|L1.338|
;;;20     			STEP_Start2();//电机 2 参数初始化
00014e  f7fffffe          BL       STEP_Start2
                  |L1.338|
;;;21     		
;;;22     		if(MotorTime_Pulse1 == 1)//新的步数执行完毕  软启停
000152  480e              LDR      r0,|L1.396|
000154  7800              LDRB     r0,[r0,#0]  ; Flagbits
000156  f0100f01          TST      r0,#1
00015a  d001              BEQ      |L1.352|
;;;23     			SOFT_Start_M1();
00015c  f7fffffe          BL       SOFT_Start_M1
                  |L1.352|
;;;24     		
;;;25     		if(MotorTime_Pulse2 == 1)//新的步数执行完毕  软启停
000160  480a              LDR      r0,|L1.396|
000162  7800              LDRB     r0,[r0,#0]  ; Flagbits
000164  f3c00040          UBFX     r0,r0,#1,#1
000168  b108              CBZ      r0,|L1.366|
;;;26     			SOFT_Start_M2();
00016a  f7fffffe          BL       SOFT_Start_M2
                  |L1.366|
00016e  e7de              B        |L1.302|
;;;27     	}	
;;;28     }
;;;29     
                          ENDP

                  |L1.368|
                          DCD      cnt1
                  |L1.372|
                          DCD      M1_state
                  |L1.376|
                          DCD      cnt2
                  |L1.380|
                          DCD      0x40006000
                  |L1.384|
                          DCD      cnt3
                  |L1.388|
                          DCD      M2_state
                  |L1.392|
                          DCD      cnt4
                  |L1.396|
                          DCD      Flagbits

                          AREA ||.data||, DATA, ALIGN=0

                  cnt1
000000  00                DCB      0x00
                  cnt2
000001  00                DCB      0x00
                  cnt3
000002  00                DCB      0x00
                  cnt4
000003  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
